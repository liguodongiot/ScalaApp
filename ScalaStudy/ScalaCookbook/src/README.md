### Chapter 1. Strings

#### Introduction

Main

#### 1.1. Testing String Equality

TestStringEqual

#### 1.2. Creating Multiline Strings

CreateMullineString

#### 1.3. Splitting Strings（分割字符串）

SplitString

#### 1.4. Substituting Variables into Strings

VariableToString

#### 1.5. Processing a String One Character at a Time

StringOneCharOneTime

#### 1.6. Finding Patterns in Strings

PatternString

#### 1.7. Replacing Patterns in Strings

ReplacePatternString

#### 1.8. Extracting Parts of a String That Match Patterns

OtherPartPatternString

#### 1.9. Accessing a Character in a String

AccessCharFromString

#### 1.10. Add Your Own Methods to the String Class

AddOwnMethodInString

AddOwnMethodInString2   版本2.10之前的使用方式

AddOwnMethodInStringTalk  Discussion

### Chapter 2. Numbers

#### Introduction

Main

#### 2.1. Parsing a Number from a String

ParseNumFromString

#### 2.2. Converting Between Numeric Types (Casting)

ConvertNumType

#### 2.3. Overriding the Default Numeric Type

OverrideDefaultNum

#### 2.4. Replacements for ++ and −−

ReplacementsPlusMinus

#### 2.5. Comparing Floating-Point Numbers

CompareFloatPointNum

#### 2.6. Handling Very Large Numbers

HandleLargeNum

#### 2.7. Generating Random Numbers

GenerateRandomNum

#### 2.8. Creating a Range, List, or Array of Numbers

CreateRangeListArray

#### 2.9. Formatting Numbers and Currency

FormatNumAndCurrency



### CHAPTER 3 Control Structures

Introduction

Main

#### 3.1. Looping with for and foreach

LoopWithForAndForeach

#### 3.2. Using for Loops with Multiple Counters

LoopWithMultipleCounter

#### 3.3. Using a for Loop with Embedded if Statements(Guards)

LoopWithEmbeddedStatements

#### 3.4. Creating a for Comprehension (for/yield Combination)

CreateComprehension

#### 3.5. Implementing break and continue

ImplBreakAndContinue

#### 3.6. Using the if Construct Like a Ternary Operator

UseIfATernaryOperator

#### 3.7. Using a Match Expression Like a switch Statement Problem

UseMatchExpression

#### 3.8. Matching Multiple Conditions with One Case Statement（多个条件匹配一个case）

MatchMultipleConditions

#### 3.9. Assigning the Result of a Match Expression to a Variable（将匹配表达式结果赋值给变量）

MatchExpressionToVariable

#### 3.10. Accessing the Value of the Default Case in a Match Expression（在匹配表达式中访问默认情况的值）

AccessDefaultValueInMatchExpression

#### 3.11. Using Pattern Matching in Match Expressions

UsePatternMatchInMatchExpression

#### 3.12. Using Case Classes in Match Expressions

UseCaseClassInMatchExpression

#### 3.13. Adding if Expressions (Guards) to Case Statements（在case中增加if表达式）

AddIfExpressionToCase

#### 3.14. Using a Match Expression Instead of isInstanceOf

UseMatchInsteadIsInstanceOf

#### 3.15. Working with a List in a Match Expression

WorkWithListInMatchExpression

#### 3.16. Matching One or More Exceptions with try/catch

MatchOneOrMoreException


#### 3.17. Declaring a Variable Before Using It in a try/catch/finally Block

DeclareVariableBeforeUseBlock


#### 3.18. Creating Your Own Control Structures

CreateYourOwnControlStructure



### CHAPTER 4 Classes and Properties（类和属性）

#### Introduction

#### 4.1. Creating a Primary Constructor（创建一个主构造器）

CreatePrimaryConstructor


#### 4.2. Controlling the Visibility of Constructor Fields（控制构造函数属性的可见性）

ControlVisibilityConstructorFields


#### 4.3. Defining Auxiliary Constructors(定义辅助构造函数)

DefineAuxiliaryConstructor



#### 4.4. Defining a Private Primary Constructor

DefinePrivatePrimaryConstructor



#### 4.5. Providing Default Values for Constructor Parameters（为构造函数参数提供默认值）

ProvideDefaultValueForConstructParam


#### 4.6. Overriding Default Accessors and Mutators（重写默认的访问器和修改器 getter or setter）

OverrideDefaultAccessorsMutators

#### 4.7. Preventing Getter and Setter Methods from Being Generated

**PreventGetSetGenerated**


#### 4.8. Assigning a Field to a Block or Function（块或函数指定一个属性）

**AssignFieldBlockFunction**

#### 4.9. Setting Uninitialized var Field Types（设置初始化变量类型）

**SetUninitializedField**

#### 4.10. Handling Constructor Parameters When Extending a Class

**HandleConstructParam**

#### 4.11. Calling a Superclass Constructor

**CallSuperclassConstructor**

#### 4.12. When to Use an Abstract Class

**UseAbstractClass**

#### 4.13. Defining Properties in an Abstract Base Class (or Trait)

**DefinePropertiesAbstractBaseClass**

#### 4.14. Generating Boilerplate Code with Case Classes（Case Class自动生成样板代码）

**GenerateBoilerplateCode**

#### 4.15. Defining an equals Method (Object Equality)

**DefineEqualMethod**

#### 4.16. Creating Inner Classes

**CreateInnerClass**


### CHAPTER 5 Methods（方法）

#### Introduction

**Main**

#### 5.1. Controlling Method Scope（控制方法的范围）

**ControlMethodScope**

#### 5.2. Calling a Method on a Superclass

**CallMethodSuperclass**

#### 5.3. Setting Default Values for Method Parameters（为方法参数设置默认值）

**SetDefaultValueMethodParam**

#### 5.4. Using Parameter Names When Calling a Method（通过参数名调用方法）

**UseParamNameCallMethod**

#### 5.5. Defining a Method That Returns Multiple Items(Tuples)（定义一个方法返回元组）

**DefineMethodReturnMultipleItem**

#### 5.6. Forcing Callers to Leave Parentheses off Accessor Methods（去除存取器方法的括号）

**ForceCallAccessMethod**

#### 5.7. Creating Methods That Take Variable-Argument Fields（创建可变参的方法）

**CreateMethodTakeField**

#### 5.8. Declaring That a Method Can Throw an Exception（声明一个方法可以抛出异常）

**DeclareMethodThrowException**

#### 5.9. Supporting a Fluent Style of Programming（流畅的编程风格 method chaining ）

**SupportFluentStyleProgram**

### Chapter 6. Objects

#### Introduction

****

#### 6.1. Object Casting

**ObjectCast**

#### 6.2. The Scala Equivalent of Java’s .class

**ScalaEquivalentJavaClass**

#### 6.3. Determining the Class of an Object

**DeterminingClassOfObject**

#### 6.4. Launching an Application with an Object

** LaunchApplicationWithObject**

#### 6.5. Creating Singletons with object

**CreateSingletonObject**

#### 6.6. Creating Static Members with Companion Objects（通过伴生对象创建静态成员）

** CreateStaticMembersObject**

#### 6.7. Putting Common Code in Package Objects（包对象）

**PutCodePackageObj**

#### 6.8. Creating Object Instances Without Using the new Keyword（创建对象实例不用new关键字）

**CreateObjectWithoutKeyword**

#### 6.9. Implement the Factory Method in Scala with apply（通过apply实现工厂方法）

**ImplementFactoryMethod **


### CHAPTER 7 Packaging and Imports

#### Introduction

#### 7.1. Packaging with the Curly Braces Style Notation


**PackageCurlyBracesStyle**

#### 7.2. Importing One or More Members

**ImportOneMoreMembers**

#### 7.3. Renaming Members on Import（import时重命名里面的成员）

**RenameMembersOnImport**

#### 7.4. Hiding a Class During the Import Process

**HideClassDureImportProcess**

#### 7.5. Using Static Imports

**UseStaticImports**

#### 7.6. Using Import Statements Anywhere

**UseImportStatementsAnywhere**

### CHAPTER 8 Traits

#### Introduction

#### 8.1. Using a Trait as an Interface（使用特质作为一个接口）

**UseTraitAsInterface**

#### 8.2. Using Abstract and Concrete Fields in Traits（在接口中使用抽象和具体的属性）

**UseAbstractConcreteFieldTraits**

#### 8.3. Using a Trait Like an Abstract Class（使用特质类似于抽象类）

**UseTraitLikeAbstractClass**

#### 8.4. Using Traits as Simple Mixins（特质混入）

**UseTraitsAsMixins**

#### 8.5. Limiting Which Classes Can Use a Trait by Inheritance（通过继承限制哪一个类使用特质）

**LimitClassUseTrait**

#### 8.6. Marking Traits So They Can Only Be Used by Subclasses of a Certain Type（标记特质仅仅只被子类确定的类型使用）

**MarkTraitBySubclasses**

#### 8.7. Ensuring a Trait Can Only Be Added to a Type That Has a Specific Method

**EnsureTraitAddedType**

#### 8.8. Adding a Trait to an Object Instance

**AddTraitToObjectInstance**

#### 8.9. Extending a Java Interface Like a Trait

**ExtendJavaInterfaceLikeTrait**


###Chapter 9. Functional Programming

#### Introduction

**Main**

#### 9.1. Using Function Literals (Anonymous Functions)（匿名函数）

**UseFunctionLiterals**

#### 9.2. Using Functions as Variables（使用函数作为变量）

**UseFunctionVariables**

#### 9.3. Defining a Method That Accepts a Simple Function Parameter（定义一个接受简单函数作为参数的方法）

**DefineMethodAcceptFunctionParam**

#### 9.4. More Complex Functions（更加复杂的函数作为参数的方法）

**MoreComplexFunctions**

#### 9.5. Using Closures（闭包）

**UseClosures**

A comparison to Java

**SimulatedClosure**

#### 9.6. Using Partially Applied Functions

**UsePartiallyAppliedFunctions**

#### 9.7. Creating a Function That Returns a Function（创建一个函数返回函数）

**CreatFunctionReturnFunction**

#### 9.8. Creating Partial Functions（局部函数）

**CreatePartialFunction**

#### 9.9. A Real-World Example

**AReadExample**

###Chapter 10. Collections（集合）

#### Introduction

**Main**

#### 10.1. Understanding the Collections Hierarchy（了解集合层次结构）

**UnderstandCollectionHierarchy**

#### 10.2. Choosing a Collection Class

**ChooseCollectionClass**

#### 10.3. Choosing a Collection Method to Solve a Problem

**ChooseCollectionMethodSolveProblem**

#### 10.4. Understanding the Performance of Collections

**UnderstandPerformanceCollections**

#### 10.5. Declaring a Type When Creating a Collection（创建集合时，声明一个类型）

**DeclareTypeWhenCreateCollection**

#### 10.6. Understanding Mutable Variables with Immutable Collections

**UnderstandMutableVariables**

#### 10.7. Make Vector Your “Go To” Immutable Sequence（Vector不可变序列）

**MakeVectorImmutableSequence**

#### 10.8. Make ArrayBuffer Your “Go To” Mutable Sequence（ArrayBuffer可变序列）

**MakeArrayBufferMutableSequence**

#### 10.9. Looping over a Collection with foreach（用foreach循环一个集合）

**LoopCollectionWithForeach**

#### 10.10. Looping over a Collection with a for Loop（用for循环一个集合）
**LoopCollectionForLoop**

#### 10.11. Using zipWithIndex or zip to Create Loop Counters（使用zipWithIndex或者zip创建一个循环计数器）
**UseZipCreateLoopCounters**

#### 10.12. Using Iterators
**UseIterators**

#### 10.13. Transforming One Collection to Another with for/yield（通过for/yield转换一个集合为另一个）
**TransformOneCollectionForYield**

#### 10.14. Transforming One Collection to Another with map（通过map转换一个集合为另一个）
**TransformOneCollectionAnotherMap**

#### 10.15. Flattening a Lsit of Lists with flatten（使多个List变成一个List）
**FlatList**

#### 10.16. Combining map and flatten with flatMap（结合map和flat等同于flatMap）
**CombineMapFlatten**

#### 10.17. Using filter to Filter a Collection（集合中使用filter过滤）
**UseFliterInCollection**

#### 10.18. Extracting a Sequence of Elements from a Collection（从集合中提取一个元素序列）
**ExtractSequenceElementFromCollection**

#### 10.19. Splitting Sequences into Subsets (groupBy,partition, etc.)
**SplitSequencesSubsets**

#### 10.20. Walking Through a Collection with the reduce and fold Methods
**WalkThroughCollectionWithReduceFold**

#### 10.21. Extracting Unique Elements from a Sequence（从序列中提取唯一元素）
**ExtractUniqueElementFromSequence**


#### 10.22. Merging Sequential Collections（合并序列集合）
**MergeSequentialCollection**

#### 10.23. Merging Two Sequential Collections into Pairs with zip
**MergeTwoSequentialCollectionPair**

#### 10.24. Creating a Lazy View on a Collection
**CreateLazyViewOnCollection**

10.25. Populating a Collection with a Range

**PopulatingCollectionWithRange**

10.26. Creating and Using Enumerations

**CreateAndUseEnumeration**

10.27. Tuples, for When You Just Need a Bag of Things
**TuplesWhenJustNeedBag**

10.28. Sorting a Collection
**SortCollection**

10.29. Converting a Collection to a String with mkString
**ConvertCollectionToStringWithMkstring**


###Chapter 11. List, Array, Map, Set (and More)

Introduction
****

11.1. Different Ways to Create and Populate a List
****

11.2. Creating a Mutable List
****

11.3. Adding Elements to a List
****

11.4. Deleting Elements from a List (or ListBuffer)
****

11.5. Merging (Concatenating) Lists
****

11.6. Using Stream, a Lazy Version of a List
****

11.7. Different Ways to Create and Update an Array
****

11.8. Creating an Array Whose Size Can Change(ArrayBuffer)
****

11.9. Deleting Array and ArrayBuffer Elements
****

11.10. Sorting Arrays
****

11.11. Creating Multidimensional Arrays
****

11.12. Creating Maps
****

11.13. Choosing a Map Implementation
****

11.14. Adding, Updating, and Removing Elements with a Mutable Map
****

11.15. Adding, Updating, and Removing Elements with Immutable Maps
****

11.16. Accessing Map Values
****

11.17. Traversing a Map
****

11.18. Getting the Keys or Values from a Map
****

11.19. Reversing Keys and Values
****

11.20. Testing for the Existence of a Key or Value in a Map
****

11.21. Filtering a Map
****

11.22. Sorting an Existing Map by Key or Value
****

11.23. Finding the Largest Key or Value in a Map
****

11.24. Adding Elements to a Set
****

11.25. Deleting Elements from Sets
****

11.26. Using Sortable Sets
****

11.27. Using a Queue
****

11.28. Using a Stack
****

11.29. Using a Range
****

Chapter 12. Files and Processes

12.0. Introduction
****

12.1. How to Open and Read a Text File
****

12.2. Writing Text Files
****

12.3. Reading and Writing Binary Files
****

12.4. How to Process Every Character in a Text File
****

12.5. How to Process a CSV File
****

12.6. Pretending that a String Is a File
****

12.7. Using Serialization
****

12.8. Listing Files in a Directory
****

12.9. Listing Subdirectories Beneath a Directory
****

12.10. Executing External Commands
****

12.11. Executing External Commands and Using STDOUT
****

12.12. Handling STDOUT and STDERR for External Commands
****

12.13. Building a Pipeline of Commands
****

12.14. Redirecting the STDOUT and STDIN of External Commands
****

12.15. Using AND (&&) and OR (||) with Processes
****

12.16. Handling Wildcard Characters in External Commands
****

12.17. How to Run a Process in a Different Directory
****

12.18. Setting Environment Variables When Running Commands
****

12.19. An Index of Methods to Execute External Commands
****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****
****

****
